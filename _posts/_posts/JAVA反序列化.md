---
title: JAVA反序列化
date: 2021-06-16 21:06:48
tags:
---

# JAVA 反序列化

## 概述

序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组，为什么要把Java对象序列化呢？因为序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。有序列化，就有反序列化，即把一个二进制内容（也就是byte[]数组）变回Java对象。有了反序列化，保存到文件中的byte[]数组又可以“变回”Java对象，或者从网络上读取byte[]并把它“变回”Java对象。

一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口，它的定义如下：

 ```java
    public interface Serializable {
}
```
![代码1](/img/pair.jpg)

![测试代码](/img/code1.jpg)
首先来看执行完序列化后生成的文件内容，可以看到反序列化数据开头包含两字节的魔术数字，这两个字节始终为十六进制的0xac ed。接下来是两字节的版本号0x00 05的数据。此外还包含了类名、成员变量的类型和个数等。
![object](/img/object.jpg)

针对序列化机制来说，如果对同一对象执行多次序列化操作，并不会得到多个对象。因为保存到磁盘的对象都有一个序列化编号，当程序试图进行序列化时，会检查该对象是否序列化过，只有该对象从未被序列化过，才会将此对象系列化为字节序列，如果此对象已经序列化过，则直接输出其序列化编号。
也就是说，由于 Java 序列化机制不会重复序列化同一个对象，只会记录已序列化对象的编号。此时如果序列化了一个可变对象（对象内容可以更改）后，若更改了对象内容再次序列化，则并不会再次将此对象转换为字节序列，而是只保存序列化编号.

## 反序列化

反序列化对象时，需要创建一个 ObjectInputStream 输入流，然后调用 ObjectInputStream 对象的 readObject() 方法得到序列化的对象即可，例如上面的代码，将生成的byte[]从Object文件中读取出来，然后执行readObject()将得到一个新的对象。
![](/img/unse.jpg)
这里体现了构造函数在序列化与反序列化中的作用，或者说，反序列化的对象是由 JVM 自己生成的对象，而不会通过构造方法生成。
从结果可以看到，反序列化并不会调用构造方法。这也是符合常理的，需要注意一点的是，反序列化 Person 对象时，需要能够找到 Person.class，否则会抛出 ClassNotFoundException 异常。


## 重写方法

在实现 Serializable 接口的同时，还可以重写 writeObject() 和 readObject() 方法，这样一旦对象被序列化或被反序列化，就会自动的调用这两个方法，而不会使用默认的序列化机制。
readObject()方法在反序列化漏洞中它起到了关键作用,readObject()方法被重写的的话，反序列化该类时调用便是重写后的readObject()方法。
重写Pair类里面的ReadObject方法：
![readObject](/img/ReadOb.jpg)
这样在执行反序列化的时候就会调用内部重写的方法，从而去执行ifconfig命令，如果该方法书写不当的话就有可能引发恶意代码的执行。所以当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。
![](/img/res1.jpg)